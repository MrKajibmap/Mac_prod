/**************************************************************************** 
 * Job:             008_101_Schedule_Modules              A5VLIHEZ.BS00003C * 
 * Description:                                                             * 
 *                                                                          * 
 * Metadata Server: rusrpomag01.rus.sas.com                                 * 
 * Port:            8561                                                    * 
 * Location:        /DWH_DWF/Blocks/008_Scheduler                           * 
 *                                                                          * 
 * Server:          SASApp                                A5VLIHEZ.AT000002 * 
 *                                                                          * 
 * Source Tables:   ETL_MODULE - etl_sys.ETL_MODULE       A5VLIHEZ.BM00004J * 
 *                  ETL_SCHEDULE_FRAME -                  A5VLIHEZ.BM00004U * 
 *                   etl_sys.ETL_SCHEDULE_FRAME                             * 
 *                  ETL_MODULE_X_RULE -                   A5VLIHEZ.BM00004L * 
 *                   etl_sys.ETL_MODULE_X_RULE                              * 
 *                  ETL_RESOURCE_REGISTRY -               A5VLIHEZ.BM00004P * 
 *                   etl_sys.ETL_RESOURCE_REGISTRY                          * 
 * Target Table:    ETL_MODULE_X_FRAME -                  A5VLIHEZ.BM00004K * 
 *                   etl_sys.ETL_MODULE_X_FRAME                             * 
 *                                                                          * 
 * Generated on:    7 апреля 2020 г. 17:31:03 MSK                           * 
 * Generated by:    sasmi                                                   * 
 * Version:         SAS Data Integration Studio 4.904                       * 
 ****************************************************************************/ 

/* Generate the process id for job  */ 
%put Process ID: &SYSJOBID;

/* General macro variables  */ 
%let jobID = %quote(A5VLIHEZ.BS00003C);
%let etls_jobName = %nrquote(008_101_Schedule_Modules);
%let etls_userID = %nrquote(sasmi);

/* Setup to capture return codes  */ 
%global job_rc trans_rc sqlrc;
%let sysrc = 0;
%let job_rc = 0;
%let trans_rc = 0;
%let sqlrc = 0;
%global etls_stepStartTime; 
/* initialize syserr to 0 */ 
data _null_; run;

%macro rcSet(error); 
   %if (&error gt &trans_rc) %then 
      %let trans_rc = &error;
   %if (&error gt &job_rc) %then 
      %let job_rc = &error;
%mend rcSet; 

%macro rcSetDS(error); 
   if &error gt input(symget('trans_rc'),12.) then 
      call symput('trans_rc',trim(left(put(&error,12.))));
   if &error gt input(symget('job_rc'),12.) then 
      call symput('job_rc',trim(left(put(&error,12.))));
%mend rcSetDS; 

/* Setup for capturing job status  */ 
%let etls_startTime = %sysfunc(datetime(),datetime.);
%let etls_recordsBefore = 0;
%let etls_recordsAfter = 0;
%let etls_lib = 0;
%let etls_table = 0;

%global etls_debug; 
%macro etls_setDebug; 
   %if %str(&etls_debug) ne 0 %then 
      OPTIONS MPRINT%str(;); 
%mend; 
%etls_setDebug; 

/*==========================================================================* 
 * Step:            Начать модуль                         A5VLIHEZ.BT000082 * 
 * Transform:       Начать модуль                                           * 
 * Description:                                                             * 
 *==========================================================================*/ 

%let transformID = %quote(A5VLIHEZ.BT000082);
%let trans_rc = 0;
%let etls_stepStartTime = %sysfunc(datetime(), datetime20.); 

%let _INPUT_count = 0; 
%let _OUTPUT_count = 0; 

%let refDesc = ;

/*****************************************************************
*  ВЕРСИЯ:
*     $Id: transform_job_start.sas 4050:7da4b3472aef 2015-08-10 09:37:44Z rusane $
*
******************************************************************
*  НАЗНАЧЕНИЕ:
*     Регистрирует начало модуля ETL.
*
*  ПАРАМЕТРЫ:
*     нет
*
******************************************************************/

%macro transform_job_start;
   %etl_job_start;
%mend transform_job_start;

%transform_job_start;


%rcSet(&syserr); 
%rcSet(&sysrc); 
%rcSet(&sqlrc); 



/** Step end Начать модуль **/

/*==========================================================================* 
 * Step:            User Written                          A5VLIHEZ.BT000083 * 
 * Transform:       User Written                                            * 
 * Description:                                                             * 
 *                                                                          * 
 * Source Tables:   ETL_MODULE - etl_sys.ETL_MODULE       A5VLIHEZ.BM00004J * 
 *                  ETL_SCHEDULE_FRAME -                  A5VLIHEZ.BM00004U * 
 *                   etl_sys.ETL_SCHEDULE_FRAME                             * 
 *                  ETL_MODULE_X_RULE -                   A5VLIHEZ.BM00004L * 
 *                   etl_sys.ETL_MODULE_X_RULE                              * 
 *                  ETL_RESOURCE_REGISTRY -               A5VLIHEZ.BM00004P * 
 *                   etl_sys.ETL_RESOURCE_REGISTRY                          * 
 * Target Table:    ETL_MODULE_X_FRAME -                  A5VLIHEZ.BM00004K * 
 *                   etl_sys.ETL_MODULE_X_FRAME                             * 
 *                                                                          * 
 * User Written:    008_100_Schedule_Modules                                * 
 *==========================================================================*/ 

%let transformID = %quote(A5VLIHEZ.BT000083);
%let trans_rc = 0;
%let etls_stepStartTime = %sysfunc(datetime(), datetime20.); 

%let _INPUT_count = 4;
%let _INPUT = etl_sys.ETL_MODULE;
%let _INPUT_connect =  DEFER=YES DBSERVER_MAX_BYTES=1 DBCLIENT_MAX_BYTES=1 PATH='rusrpomag01.rus.sas.com:1521/rpo01.rus.sas.com' AUTHDOMAIN="DwhAuth_ETL_SYS" 
;
%let _INPUT_engine = ORACLE;
%let _INPUT_memtype = DATA;
%let _INPUT_options = %nrquote();
%let _INPUT_alter = %nrquote();
%let _INPUT_path = %nrquote(/DWH_DWF/Tables/ETL_SYS/ETL_MODULE%(Table%));
%let _INPUT_type = 1;
%let _INPUT_label = %nrquote();
%let _INPUT_filetype = PhysicalTable;

%let _INPUT1 = etl_sys.ETL_MODULE;
%let _INPUT1_connect =  DEFER=YES DBSERVER_MAX_BYTES=1 DBCLIENT_MAX_BYTES=1 PATH='rusrpomag01.rus.sas.com:1521/rpo01.rus.sas.com' AUTHDOMAIN="DwhAuth_ETL_SYS" 
;
%let _INPUT1_engine = ORACLE;
%let _INPUT1_memtype = DATA;
%let _INPUT1_options = %nrquote();
%let _INPUT1_alter = %nrquote();
%let _INPUT1_path = %nrquote(/DWH_DWF/Tables/ETL_SYS/ETL_MODULE%(Table%));
%let _INPUT1_type = 1;
%let _INPUT1_label = %nrquote();
%let _INPUT1_filetype = PhysicalTable;

%let _INPUT2 = etl_sys.ETL_SCHEDULE_FRAME;
%let _INPUT2_connect =  DEFER=YES DBSERVER_MAX_BYTES=1 DBCLIENT_MAX_BYTES=1 PATH='rusrpomag01.rus.sas.com:1521/rpo01.rus.sas.com' AUTHDOMAIN="DwhAuth_ETL_SYS" 
;
%let _INPUT2_engine = ORACLE;
%let _INPUT2_memtype = DATA;
%let _INPUT2_options = %nrquote();
%let _INPUT2_alter = %nrquote();
%let _INPUT2_path = %nrquote(/DWH_DWF/Tables/ETL_SYS/ETL_SCHEDULE_FRAME%(Table%));
%let _INPUT2_type = 1;
%let _INPUT2_label = %nrquote();
%let _INPUT2_filetype = PhysicalTable;

%let _INPUT3 = etl_sys.ETL_MODULE_X_RULE;
%let _INPUT3_connect =  DEFER=YES DBSERVER_MAX_BYTES=1 DBCLIENT_MAX_BYTES=1 PATH='rusrpomag01.rus.sas.com:1521/rpo01.rus.sas.com' AUTHDOMAIN="DwhAuth_ETL_SYS" 
;
%let _INPUT3_engine = ORACLE;
%let _INPUT3_memtype = DATA;
%let _INPUT3_options = %nrquote();
%let _INPUT3_alter = %nrquote();
%let _INPUT3_path = %nrquote(/DWH_DWF/Tables/ETL_SYS/ETL_MODULE_X_RULE%(Table%));
%let _INPUT3_type = 1;
%let _INPUT3_label = %nrquote();
%let _INPUT3_filetype = PhysicalTable;

%let _INPUT4 = etl_sys.ETL_RESOURCE_REGISTRY;
%let _INPUT4_connect =  DEFER=YES DBSERVER_MAX_BYTES=1 DBCLIENT_MAX_BYTES=1 PATH='rusrpomag01.rus.sas.com:1521/rpo01.rus.sas.com' AUTHDOMAIN="DwhAuth_ETL_SYS" 
;
%let _INPUT4_engine = ORACLE;
%let _INPUT4_memtype = DATA;
%let _INPUT4_options = %nrquote();
%let _INPUT4_alter = %nrquote();
%let _INPUT4_path = %nrquote(/DWH_DWF/Tables/ETL_SYS/ETL_RESOURCE_REGISTRY%(Table%));
%let _INPUT4_type = 1;
%let _INPUT4_label = %nrquote();
%let _INPUT4_filetype = PhysicalTable;

%let _OUTPUT_count = 1;
%let _OUTPUT = etl_sys.ETL_MODULE_X_FRAME;
%let _OUTPUT_connect =  DEFER=YES DBSERVER_MAX_BYTES=1 DBCLIENT_MAX_BYTES=1 PATH='rusrpomag01.rus.sas.com:1521/rpo01.rus.sas.com' AUTHDOMAIN="DwhAuth_ETL_SYS" 
;
%let _OUTPUT_engine = ORACLE;
%let _OUTPUT_memtype = DATA;
%let _OUTPUT_options = %nrquote();
%let _OUTPUT_alter = %nrquote();
%let _OUTPUT_path = %nrquote(/DWH_DWF/Tables/ETL_SYS/ETL_MODULE_X_FRAME%(Table%));
%let _OUTPUT_type = 1;
%let _OUTPUT_label = %nrquote();
/* List of target columns to keep  */ 
%let _OUTPUT_keep = MODULE_ID FRAME_ID START_DTTM LSF_FLOW_ID;
%let _OUTPUT_col_count = 4;
%let _OUTPUT_col0_name = MODULE_ID;
%let _OUTPUT_col0_table = etl_sys.ETL_MODULE_X_FRAME;
%let _OUTPUT_col0_length = 8;
%let _OUTPUT_col0_type = ;
%let _OUTPUT_col0_format = ;
%let _OUTPUT_col0_informat = ;
%let _OUTPUT_col0_label = %nrquote(MODULE_ID);
%let _OUTPUT_col0_exp = ;
%let _OUTPUT_col0_input_count = 0;
%let _OUTPUT_col1_name = FRAME_ID;
%let _OUTPUT_col1_table = etl_sys.ETL_MODULE_X_FRAME;
%let _OUTPUT_col1_length = 8;
%let _OUTPUT_col1_type = ;
%let _OUTPUT_col1_format = ;
%let _OUTPUT_col1_informat = ;
%let _OUTPUT_col1_label = %nrquote(FRAME_ID);
%let _OUTPUT_col1_input0 = FRAME_ID;
%let _OUTPUT_col1_input0_table = etl_sys.ETL_SCHEDULE_FRAME;
%let _OUTPUT_col1_exp = ;
%let _OUTPUT_col1_input = FRAME_ID;
%let _OUTPUT_col1_input_count = 1;
%let _OUTPUT_col2_name = START_DTTM;
%let _OUTPUT_col2_table = etl_sys.ETL_MODULE_X_FRAME;
%let _OUTPUT_col2_length = 8;
%let _OUTPUT_col2_type = ;
%let _OUTPUT_col2_format = DATETIME20.;
%let _OUTPUT_col2_informat = DATETIME20.;
%let _OUTPUT_col2_label = %nrquote(START_DTTM);
%let _OUTPUT_col2_exp = ;
%let _OUTPUT_col2_input_count = 0;
%let _OUTPUT_col3_name = LSF_FLOW_ID;
%let _OUTPUT_col3_table = etl_sys.ETL_MODULE_X_FRAME;
%let _OUTPUT_col3_length = 8;
%let _OUTPUT_col3_type = ;
%let _OUTPUT_col3_format = ;
%let _OUTPUT_col3_informat = ;
%let _OUTPUT_col3_label = %nrquote(LSF_FLOW_ID);
%let _OUTPUT_col3_exp = ;
%let _OUTPUT_col3_input_count = 0;
%let _OUTPUT_filetype = PhysicalTable;

%let _OUTPUT1 = etl_sys.ETL_MODULE_X_FRAME;
%let _OUTPUT1_connect =  DEFER=YES DBSERVER_MAX_BYTES=1 DBCLIENT_MAX_BYTES=1 PATH='rusrpomag01.rus.sas.com:1521/rpo01.rus.sas.com' AUTHDOMAIN="DwhAuth_ETL_SYS" 
;
%let _OUTPUT1_engine = ORACLE;
%let _OUTPUT1_memtype = DATA;
%let _OUTPUT1_options = %nrquote();
%let _OUTPUT1_alter = %nrquote();
%let _OUTPUT1_path = %nrquote(/DWH_DWF/Tables/ETL_SYS/ETL_MODULE_X_FRAME%(Table%));
%let _OUTPUT1_type = 1;
%let _OUTPUT1_label = %nrquote();
/* List of target columns to keep  */ 
%let _OUTPUT1_keep = MODULE_ID FRAME_ID START_DTTM LSF_FLOW_ID;
%let _OUTPUT1_col_count = 4;
%let _OUTPUT1_col0_name = MODULE_ID;
%let _OUTPUT1_col0_table = etl_sys.ETL_MODULE_X_FRAME;
%let _OUTPUT1_col0_length = 8;
%let _OUTPUT1_col0_type = ;
%let _OUTPUT1_col0_format = ;
%let _OUTPUT1_col0_informat = ;
%let _OUTPUT1_col0_label = %nrquote(MODULE_ID);
%let _OUTPUT1_col0_exp = ;
%let _OUTPUT1_col0_input_count = 0;
%let _OUTPUT1_col1_name = FRAME_ID;
%let _OUTPUT1_col1_table = etl_sys.ETL_MODULE_X_FRAME;
%let _OUTPUT1_col1_length = 8;
%let _OUTPUT1_col1_type = ;
%let _OUTPUT1_col1_format = ;
%let _OUTPUT1_col1_informat = ;
%let _OUTPUT1_col1_label = %nrquote(FRAME_ID);
%let _OUTPUT1_col1_input0 = FRAME_ID;
%let _OUTPUT1_col1_input0_table = etl_sys.ETL_SCHEDULE_FRAME;
%let _OUTPUT1_col1_exp = ;
%let _OUTPUT1_col1_input = FRAME_ID;
%let _OUTPUT1_col1_input_count = 1;
%let _OUTPUT1_col2_name = START_DTTM;
%let _OUTPUT1_col2_table = etl_sys.ETL_MODULE_X_FRAME;
%let _OUTPUT1_col2_length = 8;
%let _OUTPUT1_col2_type = ;
%let _OUTPUT1_col2_format = DATETIME20.;
%let _OUTPUT1_col2_informat = DATETIME20.;
%let _OUTPUT1_col2_label = %nrquote(START_DTTM);
%let _OUTPUT1_col2_exp = ;
%let _OUTPUT1_col2_input_count = 0;
%let _OUTPUT1_col3_name = LSF_FLOW_ID;
%let _OUTPUT1_col3_table = etl_sys.ETL_MODULE_X_FRAME;
%let _OUTPUT1_col3_length = 8;
%let _OUTPUT1_col3_type = ;
%let _OUTPUT1_col3_format = ;
%let _OUTPUT1_col3_informat = ;
%let _OUTPUT1_col3_label = %nrquote(LSF_FLOW_ID);
%let _OUTPUT1_col3_exp = ;
%let _OUTPUT1_col3_input_count = 0;
%let _OUTPUT1_filetype = PhysicalTable;

/*---- Start of User Written Code  ----*/ 

/*****************************************************************
* ВЕРСИЯ:
*   $Id: 008_100_Schedule_Modules.sas 4391:b5c9bbc4da65 2015-08-20 08:49:20Z rusane $
*
******************************************************************
* НАЗНАЧЕНИЕ:
*   Планировщик постановки заданий в очередь LSF.
*   Должен работать постоянно, например, запускаясь раз в 10 мин.
*
******************************************************************
* Использует:
*     %error_check
*     %ETL_DBMS_connect
*     %job_event_reg
*     %member_obs
*     %util_loop
*     %util_loop_data
*
* Устанавливает макропеременные:
*     нет
*
******************************************************************
* 14-02-2012   Нестерёнок  Начальное кодирование
* 23-04-2012   Нестерёнок  Добавлены ограничения по ресурсам
* 30-04-2014   Нестерёнок  Добавлена защита от пересекающихся интервалов
* 17-02-2015   Сазонов     Для CMD вызов через &START_SAS_CMD
* 01-04-2015   Сазонов     Изменения для запуска без LSF
* 28-08-2017   Куликовский Добавлена проверка на уже работающий поток в LSF
******************************************************************/


/*********************************************** Ограничения по времени ****************************************************/

/* Получаем список модулей, для которых наступило окно запуска, но которые еще не были распределены */
proc sql;
   create table t_008_100_modules as
      select
         sf.schedule_cd,
         sf.frame_id,
         m.module_id,
         m.module_type_cd,
         m.module_txt
      from
         ETL_SYS.ETL_SCHEDULE_FRAME as sf,
         (select module_id, filter_schedule_cd as schedule_cd from ETL_SYS.ETL_MODULE_X_RULE
            where filter_schedule_cd is not null
         ) as mxs,
         ETL_SYS.ETL_MODULE as m
      where
         sf.schedule_cd = mxs.schedule_cd and
         mxs.module_id = m.module_id and
/*         sf.open_dttm le &JOB_START_DTTM le sf.close_dttm*/
			((sf.open_dttm le &JOB_START_DTTM le sf.close_dttm 
         and not exists (
            select 1 from ETL_SYS.ETL_MODULE_X_FRAME
            where module_id = m.module_id and frame_id = sf.frame_id
					         )
			) or sf.schedule_cd = 'INIT')
   ;
quit;
%error_check (mpStepType=SQL);

/* Защита от дураков */
proc sort
   data=    t_008_100_modules
   out=     t_008_100_modules (index=(module_id /unique))
   dupout=  t_008_100_modules_dup
   nodupkey
;
   by module_id;
run;

%macro validate_modules;
   %local lmvObs;
   %let lmvObs = %member_obs(mpData=t_008_100_modules_dup);
   %if &lmvObs le 0 %then %return;

   %job_event_reg (
      mpEventTypeCode=  DATA_VALIDATION_FAILED,
      mpEventValues=    %bquote(Задвоенные интервалы модулей (&lmvObs) отброшены)
   );
%mend validate_modules;
%validate_modules;

/*********************************************** Ограничения по ресурсам ****************************************************/
/* Макросы для обработки правил */

/* Макрос применяет одно правило к набору module_data */
%macro process_rule (mpCancel=);
   /* Оптимизация:  если не осталось правил, для которых есть записи в нужном состоянии, то прекратить обработку правил */
   %local lmvFutureStateCount;
   %let lmvFutureStateCount = 0;
   proc sql noprint;
      select count(*) into :lmvFutureStateCount
      from module_data
      where state_cd in (
         select
            distinct state_cd
         from
            t_008_100_rules
         where
            module_id = &module_id and rule_id ge &rule_id
      );
   quit;
   %error_check (mpStepType=SQL);

   %if &lmvFutureStateCount = 0 %then %do;
      %let &mpCancel = Y;
      %job_event_reg (mpEventTypeCode=STAT_MODULE,
                     mpEventDesc=Планировщик остановил применение правил к модулю &module_id,
                     mpEventValues= %bquote(Все записи вне области действия правил) );
      %return;
   %end;

   /* Находим записи, на которые действует правило */
   proc sql feedback;
      create table module_data_upd as
         select
            m.resource_id,
            m.version_id
         from
            module_data as m
            inner join (
               /* Получаем список подходящих групп или, если нет группировки, то единственную запись */
               select
                  distinct %member_vars_expand(state_cd &filter_by_group, {}, %str(, ))
               from module_data
               where
                  state_cd = "&state_cd"
                  %if %length(&filter_schedule_cd) gt 0 %then %do;
                     and ("&filter_schedule_cd" in (
                        select distinct schedule_cd from t_008_100_modules where module_id = &module_id
                     ))
                  %end;
                  %if %length(&filter_resource_group_cd) gt 0 %then %do;
                     and (resource_group_cd in ("%sysfunc(tranwrd(%superq(filter_resource_group_cd),%str(,),%str(%",%")))"))
                  %end;
                  %if %length(&filter_resource_cd) gt 0 %then %do;
                     and (resource_cd in ("%sysfunc(tranwrd(%superq(filter_resource_cd),%str(,),%str(%",%")))"))
                  %end;
                  %if %length(&filter_status_cd) gt 0 %then %do;
                     and (status_cd in ("%sysfunc(tranwrd(%superq(filter_status_cd),%str(,),%str(%",%")))"))
                  %end;
               %if %length(&filter_extra_txt) gt 0 %then %do;
                  having (&filter_extra_txt)
               %end;
            ) as a
            on
               %member_vars_expand(state_cd &filter_by_group, m.{}=a.{}, %str( and ))
      ;
      create unique index pk on module_data_upd (resource_id, version_id)
      ;
   quit;
   %error_check (mpStepType=SQL);

   /* Отладка */
   %if &ETL_DEBUG %then %do;
      data module_data_&rule_id.;
         set module_data;
      run;
      data module_data_upd_&rule_id.;
         set module_data_upd;
      run;
   %end;

   /* Переводим в следующее состояние */
   data module_data_next;
      set module_data end=end;

      /* Статистика */
      retain stat_unchanged_cnt stat_next_cnt stat_else_cnt 0;
      drop   stat_unchanged_cnt stat_next_cnt stat_else_cnt  ;

      if state_cd = "&state_cd" then do;
         set module_data_upd key=pk /unique;
         _error_ = 0;
         if _iorc_ = &IORC_SOK then do;
            state_cd = "&next_state_cd";
            stat_next_cnt + 1;
         end;
         else do;
            state_cd = "&else_state_cd";
            stat_else_cnt + 1;
         end;
         if state_cd ne "R" then output;
      end;
      else do;
         stat_unchanged_cnt + 1;
      end;

      if end then do;
         call symputx ("stat_unchanged_cnt", stat_unchanged_cnt);
         call symputx ("stat_next_cnt",      stat_next_cnt);
         call symputx ("stat_else_cnt",      stat_else_cnt);
      end;
   run;
   %error_check (mpStepType=DATA);

   proc append base=module_data data=module_data_next;
   run;
   %error_check (mpStepType=DATA);

   /* Отладка */
   %if &ETL_DEBUG %then %do;
      data module_data_next_&rule_id.;
         set module_data_next;
      run;
   %end;

   /* Статистика */
   %let next_state_cd = &next_state_cd;
   %let else_state_cd = &else_state_cd;
   %job_event_reg (mpEventTypeCode=STAT_MODULE,
                     mpEventDesc=Планировщик применил правило &rule_id к модулю &module_id,
                     mpEventValues= %bquote(Перешло в "&next_state_cd" &stat_next_cnt записей, в "&else_state_cd" - &stat_else_cnt, не изменилось - &stat_unchanged_cnt) );
%mend process_rule;

/* Макрос применяет все правила модуля к набору t_008_100_registry из реестра */
/* Затем выводит результат (кол-во строк, пришедших в конечное состояние успеха A (Accept)) */
%macro check_module(mpModuleId);
   data module_data;
      if 0 then set etl_sys.etl_module_x_rule (keep= module_id state_cd);
      module_id   = &mpModuleId;
      state_cd    = "S";
      set t_008_100_registry;
   run;
   %error_check (mpStepType=DATA);

   sasfile work.module_data load;
   %util_loop_data (mpData=t_008_100_rules, mpLoopMacro=process_rule, mpWhere= module_id=&mpModuleId, mpCancellable=Y);
   sasfile work.module_data close;

   proc sql;
      create table rule_ok as select
         &mpModuleId    as module_id,
         count(*)       as success_obs_cnt
      from module_data
         where state_cd = "A"
      ;
   quit;
   %error_check (mpStepType=SQL);

   proc append base=t_008_100_rule_ok data=rule_ok;
   run;
   %error_check (mpStepType=DATA);
%mend check_module;


/* Отбираем актуальные (не C) записи реестра */
/* Для запуска модуля хотя бы одна из них должна быть переведена из начального состояния S (Start) */
/* в конечное состояние успеха A (Accept) при помощи указанных для модуля правил */
data t_008_100_registry_dummy;
   if 0 then set etl_sys.etl_resource_registry;
   resource_id = -1;
   output;
run;
%error_check (mpStepType=DATA);

data t_008_100_registry;
   set
      etl_sys.etl_resource_registry (where= (status_cd ne "C"))
      t_008_100_registry_dummy (in= in_dummy)
   ;

   /* Добавляем расчетные переменные */
   length resource_cd resource_group_cd $32;
   resource_cd          = put (resource_id, res_id_cd.);
   resource_group_cd    = put (resource_id, res_id_grp.);

   /* В случае отсутствия записей в реестре добавляем виртуальную запись */
   /* Она позволит валидировать правила, рассчитанные на "все записи" */
   if not (in_dummy and _n_ gt 1) then output;
run;
%error_check (mpStepType=DATA);

/* Выполняем для каждого модуля все его правила */
%macro check_all;
   %local lmvModuleList;
   proc sql noprint;
      create table t_008_100_rules as select *
      from etl_sys.etl_module_x_rule
      order by module_id, rule_id
      ;
      select distinct module_id into :lmvModuleList separated by " " from t_008_100_rules
      ;
   quit;

   data t_008_100_rule_ok (index= (module_id /unique));
      length module_id success_obs_cnt 8;
      delete;
   run;

   %if %length(&lmvModuleList) gt 0 %then %do;
      %util_loop(mpMacroName=check_module, mpWith=&lmvModuleList);
   %end;
   %else %do;
      %job_event_reg (mpEventTypeCode=UNEXPECTED_ARGUMENT,
                      mpEventValues= %bquote(Не задано никаких правил, модули не будут запускаться) );
   %end;
%mend check_all;
%check_all;


/*********************************************** Запуск готовых модулей ****************************************************/
/* Отбираем успешные модули */
data t_008_100_modules_ready;
   merge
      t_008_100_modules (in= in_modules)
      t_008_100_rule_ok (in= in_rule_ok)
   ;
   by module_id;

   /* TODO: модули без расписания не запускаются */
   if in_modules;
   if not in_rule_ok then do;
      _error_ = 0;
       call missing(success_obs_cnt);
   end;

   /* Если у модуля нет ограничений по ресурсам, то считаем ограничения выполненными */
   if (success_obs_cnt gt 0) or missing(success_obs_cnt) then ready_flg = "Y";
run;
%error_check (mpStepType=DATA);

/* Выводим результаты в лог */
%macro log_ready;
   %local lmvEventType;
   %if &ready_flg = Y %then
      %let lmvEventType = SCHEDULER_MODULE_READY;
   %else
      %let lmvEventType = SCHEDULER_MODULE_NOT_READY;

   %let module_txt = &module_txt;
   %job_event_reg (mpEventTypeCode=&lmvEventType,
                   mpEventValues= %bquote(&module_txt (&module_id)) );
%mend log_ready;
%util_loop_data (mpData=t_008_100_modules_ready, mpLoopMacro=log_ready);


/* Исполняем готовые к распределению модули */
%macro schedule_ready;
   /* Определяем команду, которую надо выполнить */
   %local lmvCommand;
   %if &module_type_cd = LSF %then %do;
      %let lmvCommand = /opt/sas/platform/pm/10.2/bin/jtrigger &module_txt;
   %end;
   %else %if &module_type_cd = CMD %then %do;
      %let lmvCommand = &module_txt;
   %end;
   /* Workspace Server */
   %else %if &module_type_cd = WSS %then %do;
      %let lmvCommand = &SAS_START_CMD !ETL_DATA_ROOT/deployed/&module_txt..sas;
   %end;
   %else %do;
      %job_event_reg (mpEventTypeCode=ILLEGAL_ARGUMENT, mpLevel=E,
                      mpEventValues= %bquote(&module_txt: Неизвестный тип модуля &module_type_cd) );
      %return;
   %end;

   /* Выполняем, выводим лог */
   %local lmvCommandRc lmvCommandMsg;
   %sys_command (
      mpCommand= &lmvCommand,
      mpResultKey=lmvCommandRc,
      mpMsgKey=lmvCommandMsg
   );

   /* Регистрируем результат */
   %let module_txt = &module_txt;
   %if &lmvCommandRc = 0 %then %do;
      %job_event_reg (mpEventTypeCode=SCHEDULER_MODULE_KICKOFF,
                      mpEventValues= %bquote(&module_txt (&module_id)) );
   %if &module_type_cd = LSF %then %do;
      /* Получаем идентификатор задания LSF */
      %local lmvFlowId lmvRx lmvPos;
      %let lmvFlowId    = .;
      %let lmvRx        = %sysfunc(prxparse (/Flow id <(\d+)>/o));
      %let lmvPos       = %sysfunc(prxmatch (&lmvRx, &lmvCommandMsg));
      %if &lmvPos gt 0 %then
         %let lmvFlowId = %sysfunc(prxposn (&lmvRx, 1, &lmvCommandMsg));
      %syscall prxfree (lmvRx);
   %end;
   %else %if &module_type_cd = WSS %then %do;
      %local lmvFlowId;
      %let lmvFlowId  = &lmvCommandMsg;
   %end;

		%if &schedule_cd ne INIT %then %do;
	      /* Закрываем использованное окно */
	      proc sql;
	         %&ETL_DBMS._connect(mpLoginSet=ETL_SYS);
	         execute by &ETL_DBMS (
	            insert into ETL_SYS.ETL_MODULE_X_FRAME (
	               module_id,
	               frame_id,
	               start_dttm,
	               lsf_flow_id
	            )
	            values (
	               %&ETL_DBMS._number(&module_id),
	               %&ETL_DBMS._number(&frame_id),
	               %&ETL_DBMS._timestamp(&JOB_START_DTTM),
	               %&ETL_DBMS._number(&lmvFlowId)
	            )
	         );
	         disconnect from &ETL_DBMS;
	      quit;
	   %end;

   %end;
   %else %do;
      %job_event_reg (mpEventTypeCode=XCMD_FAILED,
                      mpEventValues= %bquote(&lmvCommandMsg) );
      %job_event_reg (mpEventTypeCode=SCHEDULER_MODULE_FAILED,
                      mpEventValues= %bquote(&module_txt (&module_id)) );
   %end;
%mend schedule_ready;
%util_loop_data (mpData=t_008_100_modules_ready, mpLoopMacro=schedule_ready, mpWhere= ready_flg = "Y");

/*---- End of User Written Code  ----*/ 

%rcSet(&syserr); 
%rcSet(&sqlrc); 


/** Step end User Written **/

/*==========================================================================* 
 * Step:            Завершить модуль                      A5VLIHEZ.BT000084 * 
 * Transform:       Завершить модуль                                        * 
 * Description:                                                             * 
 *==========================================================================*/ 

%let transformID = %quote(A5VLIHEZ.BT000084);
%let trans_rc = 0;
%let etls_stepStartTime = %sysfunc(datetime(), datetime20.); 

%let _INPUT_count = 0; 
%let _OUTPUT_count = 0; 

%let refDesc = ;

/*****************************************************************
* ВЕРСИЯ:
*   $Id: transform_job_finish.sas 4050:7da4b3472aef 2015-08-10 09:37:44Z rusane $
*
******************************************************************
* НАЗНАЧЕНИЕ:
*   Регистрирует конец модуля ETL.
*
* ПАРАМЕТРЫ:
*   нет
*
******************************************************************/

%macro transform_job_finish;
   %etl_job_finish;
%mend transform_job_finish;

%transform_job_finish;


%rcSet(&syserr); 
%rcSet(&sysrc); 
%rcSet(&sqlrc); 



/** Step end Завершить модуль **/

%let etls_endTime = %sysfunc(datetime(),datetime.);

